{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { isPlainObject as e } from \"is-plain-object\";\nfunction t() {\n  return t = Object.assign ? Object.assign.bind() : function (e) {\n    for (var t = 1; t < arguments.length; t++) {\n      var r = arguments[t];\n      for (var n in r) Object.prototype.hasOwnProperty.call(r, n) && (e[n] = r[n]);\n    }\n    return e;\n  }, t.apply(this, arguments);\n}\nfunction r(e, t) {\n  if (null == e) return {};\n  var r,\n    n,\n    i = {},\n    o = Object.keys(e);\n  for (n = 0; n < o.length; n++) t.indexOf(r = o[n]) >= 0 || (i[r] = e[r]);\n  return i;\n}\nconst n = {\n    silent: !1,\n    logLevel: \"warn\"\n  },\n  i = [\"validator\"],\n  o = Object.prototype,\n  a = o.toString,\n  s = o.hasOwnProperty,\n  u = /^\\s*function (\\w+)/;\nfunction l(e) {\n  var t;\n  const r = null !== (t = null == e ? void 0 : e.type) && void 0 !== t ? t : e;\n  if (r) {\n    const e = r.toString().match(u);\n    return e ? e[1] : \"\";\n  }\n  return \"\";\n}\nconst c = e,\n  f = e => e;\nlet d = f;\nif (\"production\" !== process.env.NODE_ENV) {\n  const e = \"undefined\" != typeof console;\n  d = e ? function (e, t = n.logLevel) {\n    !1 === n.silent && console[t](`[VueTypes warn]: ${e}`);\n  } : f;\n}\nconst p = (e, t) => s.call(e, t),\n  y = Number.isInteger || function (e) {\n    return \"number\" == typeof e && isFinite(e) && Math.floor(e) === e;\n  },\n  v = Array.isArray || function (e) {\n    return \"[object Array]\" === a.call(e);\n  },\n  h = e => \"[object Function]\" === a.call(e),\n  b = e => c(e) && p(e, \"_vueTypes_name\"),\n  g = e => c(e) && (p(e, \"type\") || [\"_vueTypes_name\", \"validator\", \"default\", \"required\"].some(t => p(e, t)));\nfunction O(e, t) {\n  return Object.defineProperty(e.bind(t), \"__original\", {\n    value: e\n  });\n}\nfunction m(e, t, r = !1) {\n  let n,\n    i = !0,\n    o = \"\";\n  n = c(e) ? e : {\n    type: e\n  };\n  const a = b(n) ? n._vueTypes_name + \" - \" : \"\";\n  if (g(n) && null !== n.type) {\n    if (void 0 === n.type || !0 === n.type) return i;\n    if (!n.required && void 0 === t) return i;\n    v(n.type) ? (i = n.type.some(e => !0 === m(e, t, !0)), o = n.type.map(e => l(e)).join(\" or \")) : (o = l(n), i = \"Array\" === o ? v(t) : \"Object\" === o ? c(t) : \"String\" === o || \"Number\" === o || \"Boolean\" === o || \"Function\" === o ? function (e) {\n      if (null == e) return \"\";\n      const t = e.constructor.toString().match(u);\n      return t ? t[1] : \"\";\n    }(t) === o : t instanceof n.type);\n  }\n  if (!i) {\n    const e = `${a}value \"${t}\" should be of type \"${o}\"`;\n    return !1 === r ? (d(e), !1) : e;\n  }\n  if (p(n, \"validator\") && h(n.validator)) {\n    const e = d,\n      o = [];\n    if (d = e => {\n      o.push(e);\n    }, i = n.validator(t), d = e, !i) {\n      const e = (o.length > 1 ? \"* \" : \"\") + o.join(\"\\n* \");\n      return o.length = 0, !1 === r ? (d(e), i) : e;\n    }\n  }\n  return i;\n}\nfunction j(e, t) {\n  const r = Object.defineProperties(t, {\n      _vueTypes_name: {\n        value: e,\n        writable: !0\n      },\n      isRequired: {\n        get() {\n          return this.required = !0, this;\n        }\n      },\n      def: {\n        value(e) {\n          return void 0 === e ? (p(this, \"default\") && delete this.default, this) : h(e) || !0 === m(this, e, !0) ? (this.default = v(e) ? () => [...e] : c(e) ? () => Object.assign({}, e) : e, this) : (d(`${this._vueTypes_name} - invalid default value: \"${e}\"`), this);\n        }\n      }\n    }),\n    {\n      validator: n\n    } = r;\n  return h(n) && (r.validator = O(n, r)), r;\n}\nfunction _(e, t) {\n  const r = j(e, t);\n  return Object.defineProperty(r, \"validate\", {\n    value(e) {\n      return h(this.validator) && d(`${this._vueTypes_name} - calling .validate() will overwrite the current custom validator function. Validator info:\\n${JSON.stringify(this)}`), this.validator = O(e, this), this;\n    }\n  });\n}\nfunction T(e, t, n) {\n  const o = function (e) {\n    const t = {};\n    return Object.getOwnPropertyNames(e).forEach(r => {\n      t[r] = Object.getOwnPropertyDescriptor(e, r);\n    }), Object.defineProperties({}, t);\n  }(t);\n  if (o._vueTypes_name = e, !c(n)) return o;\n  const {\n      validator: a\n    } = n,\n    s = r(n, i);\n  if (h(a)) {\n    let {\n      validator: e\n    } = o;\n    e && (e = null !== (l = (u = e).__original) && void 0 !== l ? l : u), o.validator = O(e ? function (t) {\n      return e.call(this, t) && a.call(this, t);\n    } : a, o);\n  }\n  var u, l;\n  return Object.assign(o, s);\n}\nfunction $(e) {\n  return e.replace(/^(?!\\s*$)/gm, \"  \");\n}\nconst w = () => _(\"any\", {}),\n  P = () => _(\"function\", {\n    type: Function\n  }),\n  x = () => _(\"boolean\", {\n    type: Boolean\n  }),\n  E = () => _(\"string\", {\n    type: String\n  }),\n  N = () => _(\"number\", {\n    type: Number\n  }),\n  q = () => _(\"array\", {\n    type: Array\n  }),\n  A = () => _(\"object\", {\n    type: Object\n  }),\n  V = () => j(\"integer\", {\n    type: Number,\n    validator: e => y(e)\n  }),\n  S = () => j(\"symbol\", {\n    validator: e => \"symbol\" == typeof e\n  }),\n  k = () => ({\n    type: null\n  });\nfunction D(e, t = \"custom validation failed\") {\n  if (\"function\" != typeof e) throw new TypeError(\"[VueTypes error]: You must provide a function as argument\");\n  return j(e.name || \"<<anonymous function>>\", {\n    type: null,\n    validator(r) {\n      const n = e(r);\n      return n || d(`${this._vueTypes_name} - ${t}`), n;\n    }\n  });\n}\nfunction L(e) {\n  if (!v(e)) throw new TypeError(\"[VueTypes error]: You must provide an array as argument.\");\n  const t = `oneOf - value should be one of \"${e.join('\", \"')}\".`,\n    r = e.reduce((e, t) => {\n      if (null != t) {\n        const r = t.constructor;\n        -1 === e.indexOf(r) && e.push(r);\n      }\n      return e;\n    }, []);\n  return j(\"oneOf\", {\n    type: r.length > 0 ? r : void 0,\n    validator(r) {\n      const n = -1 !== e.indexOf(r);\n      return n || d(t), n;\n    }\n  });\n}\nfunction F(e) {\n  if (!v(e)) throw new TypeError(\"[VueTypes error]: You must provide an array as argument\");\n  let t = !1,\n    r = [];\n  for (let n = 0; n < e.length; n += 1) {\n    const i = e[n];\n    if (g(i)) {\n      if (b(i) && \"oneOf\" === i._vueTypes_name && i.type) {\n        r = r.concat(i.type);\n        continue;\n      }\n      if (h(i.validator) && (t = !0), !0 === i.type || !i.type) {\n        d('oneOfType - invalid usage of \"true\" or \"null\" as types.');\n        continue;\n      }\n      r = r.concat(i.type);\n    } else r.push(i);\n  }\n  r = r.filter((e, t) => r.indexOf(e) === t);\n  const n = r.length > 0 ? r : null;\n  return j(\"oneOfType\", t ? {\n    type: n,\n    validator(t) {\n      const r = [],\n        n = e.some(e => {\n          const n = m(b(e) && \"oneOf\" === e._vueTypes_name ? e.type || null : e, t, !0);\n          return \"string\" == typeof n && r.push(n), !0 === n;\n        });\n      return n || d(`oneOfType - provided value does not match any of the ${r.length} passed-in validators:\\n${$(r.join(\"\\n\"))}`), n;\n    }\n  } : {\n    type: n\n  });\n}\nfunction Y(e) {\n  return j(\"arrayOf\", {\n    type: Array,\n    validator(t) {\n      let r = \"\";\n      const n = t.every(t => (r = m(e, t, !0), !0 === r));\n      return n || d(`arrayOf - value validation error:\\n${$(r)}`), n;\n    }\n  });\n}\nfunction B(e) {\n  return j(\"instanceOf\", {\n    type: e\n  });\n}\nfunction I(e) {\n  return j(\"objectOf\", {\n    type: Object,\n    validator(t) {\n      let r = \"\";\n      const n = Object.keys(t).every(n => (r = m(e, t[n], !0), !0 === r));\n      return n || d(`objectOf - value validation error:\\n${$(r)}`), n;\n    }\n  });\n}\nfunction J(e) {\n  const t = Object.keys(e),\n    r = t.filter(t => {\n      var r;\n      return !(null === (r = e[t]) || void 0 === r || !r.required);\n    }),\n    n = j(\"shape\", {\n      type: Object,\n      validator(n) {\n        if (!c(n)) return !1;\n        const i = Object.keys(n);\n        if (r.length > 0 && r.some(e => -1 === i.indexOf(e))) {\n          const e = r.filter(e => -1 === i.indexOf(e));\n          return d(1 === e.length ? `shape - required property \"${e[0]}\" is not defined.` : `shape - required properties \"${e.join('\", \"')}\" are not defined.`), !1;\n        }\n        return i.every(r => {\n          if (-1 === t.indexOf(r)) return !0 === this._vueTypes_isLoose || (d(`shape - shape definition does not include a \"${r}\" property. Allowed keys: \"${t.join('\", \"')}\".`), !1);\n          const i = m(e[r], n[r], !0);\n          return \"string\" == typeof i && d(`shape - \"${r}\" property validation error:\\n ${$(i)}`), !0 === i;\n        });\n      }\n    });\n  return Object.defineProperty(n, \"_vueTypes_isLoose\", {\n    writable: !0,\n    value: !1\n  }), Object.defineProperty(n, \"loose\", {\n    get() {\n      return this._vueTypes_isLoose = !0, this;\n    }\n  }), n;\n}\nconst M = [\"name\", \"validate\", \"getter\"],\n  R = /*#__PURE__*/(() => {\n    var e;\n    return (e = class {\n      static get any() {\n        return w();\n      }\n      static get func() {\n        return P().def(this.defaults.func);\n      }\n      static get bool() {\n        return x().def(this.defaults.bool);\n      }\n      static get string() {\n        return E().def(this.defaults.string);\n      }\n      static get number() {\n        return N().def(this.defaults.number);\n      }\n      static get array() {\n        return q().def(this.defaults.array);\n      }\n      static get object() {\n        return A().def(this.defaults.object);\n      }\n      static get integer() {\n        return V().def(this.defaults.integer);\n      }\n      static get symbol() {\n        return S();\n      }\n      static get nullable() {\n        return {\n          type: null\n        };\n      }\n      static extend(e) {\n        if (v(e)) return e.forEach(e => this.extend(e)), this;\n        const {\n            name: t,\n            validate: n = !1,\n            getter: i = !1\n          } = e,\n          o = r(e, M);\n        if (p(this, t)) throw new TypeError(`[VueTypes error]: Type \"${t}\" already defined`);\n        const {\n          type: a\n        } = o;\n        if (b(a)) return delete o.type, Object.defineProperty(this, t, i ? {\n          get: () => T(t, a, o)\n        } : {\n          value(...e) {\n            const r = T(t, a, o);\n            return r.validator && (r.validator = r.validator.bind(r, ...e)), r;\n          }\n        });\n        let s;\n        return s = i ? {\n          get() {\n            const e = Object.assign({}, o);\n            return n ? _(t, e) : j(t, e);\n          },\n          enumerable: !0\n        } : {\n          value(...e) {\n            const r = Object.assign({}, o);\n            let i;\n            return i = n ? _(t, r) : j(t, r), r.validator && (i.validator = r.validator.bind(i, ...e)), i;\n          },\n          enumerable: !0\n        }, Object.defineProperty(this, t, s);\n      }\n    }).defaults = {}, e.sensibleDefaults = void 0, e.config = n, e.custom = D, e.oneOf = L, e.instanceOf = B, e.oneOfType = F, e.arrayOf = Y, e.objectOf = I, e.shape = J, e.utils = {\n      validate: (e, t) => !0 === m(t, e, !0),\n      toType: (e, t, r = !1) => r ? _(e, t) : j(e, t)\n    }, e;\n  })();\nfunction z(e = {\n  func: () => {},\n  bool: !0,\n  string: \"\",\n  number: 0,\n  array: () => [],\n  object: () => ({}),\n  integer: 0\n}) {\n  var r;\n  return (r = class extends R {\n    static get sensibleDefaults() {\n      return t({}, this.defaults);\n    }\n    static set sensibleDefaults(r) {\n      this.defaults = !1 !== r ? t({}, !0 !== r ? r : e) : {};\n    }\n  }).defaults = t({}, e), r;\n}\nclass C extends z() {}\nexport { w as any, q as array, Y as arrayOf, x as bool, n as config, z as createTypes, D as custom, C as default, T as fromType, P as func, B as instanceOf, V as integer, k as nullable, N as number, A as object, I as objectOf, L as oneOf, F as oneOfType, J as shape, E as string, S as symbol, j as toType, _ as toValidableType, m as validateType };","map":{"version":3,"names":["n","silent","logLevel","i","o","Object","prototype","a","toString","s","hasOwnProperty","u","l","e","t","r","type","match","c","f","d","process","env","NODE_ENV","console","p","has","call","y","Number","isInteger","isFinite","Math","floor","v","Array","isArray","h","b","g","some","O","defineProperty","bind","value","m","_vueTypes_name","required","map","join","constructor","validator","push","length","j","defineProperties","writable","isRequired","get","def","default","assign","_","JSON","stringify","T","getOwnPropertyNames","forEach","getOwnPropertyDescriptor","__original","$","replace","w","any","P","Function","x","bool","Boolean","E","String","N","number","q","A","V","integer","S","symbol","k","nullable","D","TypeError","name","L","reduce","indexOf","F","concat","filter","Y","every","B","I","keys","J","_vueTypes_isLoose","M","R","func","defaults","string","array","object","extend","validate","getter","enumerable","sensibleDefaults","config","custom","oneOf","instanceOf","oneOfType","arrayOf","objectOf","shape","utils","toType","z","C","createTypes","fromType","toValidableType","validateType"],"sources":["../src/config.ts","../src/utils.ts","../src/validators/native.ts","../src/validators/custom.ts","../src/validators/oneof.ts","../src/validators/oneoftype.ts","../src/validators/arrayof.ts","../src/validators/instanceof.ts","../src/validators/objectof.ts","../src/validators/shape.ts","../src/index.ts","../src/sensibles.ts"],"sourcesContent":["import { VueTypesConfig } from './types'\n\nexport const config: VueTypesConfig = {\n  silent: false,\n  logLevel: 'warn',\n}\n","import { isPlainObject as _isPlainObject } from 'is-plain-object'\nimport { config } from './config'\nimport {\n  VueTypeDef,\n  VueTypeValidableDef,\n  VueProp,\n  InferType,\n  PropOptions,\n} from './types'\n\nconst ObjProto = Object.prototype\nconst toString = ObjProto.toString\nexport const hasOwn = ObjProto.hasOwnProperty\n\nconst FN_MATCH_REGEXP = /^\\s*function (\\w+)/\n\n// https://github.com/vuejs/vue/blob/dev/src/core/util/props.js#L177\nexport function getType(\n  fn: VueProp<any> | (() => any) | (new (...args: any[]) => any),\n): string {\n  const type = (fn as VueProp<any>)?.type ?? fn\n  if (type) {\n    const match = type.toString().match(FN_MATCH_REGEXP)\n    return match ? match[1] : ''\n  }\n  return ''\n}\n\nexport function getNativeType(value: any): string {\n  if (value === null || value === undefined) return ''\n  const match = value.constructor.toString().match(FN_MATCH_REGEXP)\n  return match ? match[1] : ''\n}\n\ntype PlainObject = { [key: string]: any }\nexport const isPlainObject = _isPlainObject as (obj: any) => obj is PlainObject\n\n/**\n * No-op function\n */\n// eslint-disable-next-line @typescript-eslint/no-empty-function\nexport function noop() {}\n\n/**\n * A function that returns its first argument\n *\n * @param arg - Any argument\n */\nexport const identity = (arg: any) => arg\n\nlet warn: (msg: string) => string | void = identity\n\nif (process.env.NODE_ENV !== 'production') {\n  const hasConsole = typeof console !== 'undefined'\n  warn = hasConsole\n    ? function warn(msg: string, level = config.logLevel) {\n        if (config.silent === false) {\n          console[level](`[VueTypes warn]: ${msg}`)\n        }\n      }\n    : identity\n}\n\nexport { warn }\n\n/**\n * Checks for a own property in an object\n *\n * @param {object} obj - Object\n * @param {string} prop - Property to check\n */\nexport const has = <T, U extends keyof T>(obj: T, prop: U) =>\n  hasOwn.call(obj, prop)\n\n/**\n * Determines whether the passed value is an integer. Uses `Number.isInteger` if available\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isInteger\n * @param {*} value - The value to be tested for being an integer.\n * @returns {boolean}\n */\nexport const isInteger =\n  Number.isInteger ||\n  function isInteger(value: unknown): value is number {\n    return (\n      typeof value === 'number' &&\n      isFinite(value) &&\n      Math.floor(value) === value\n    )\n  }\n\n/**\n * Determines whether the passed value is an Array.\n *\n * @param {*} value - The value to be tested for being an array.\n * @returns {boolean}\n */\nexport const isArray =\n  Array.isArray ||\n  function isArray(value): value is any[] {\n    return toString.call(value) === '[object Array]'\n  }\n\n/**\n * Checks if a value is a function\n *\n * @param {any} value - Value to check\n * @returns {boolean}\n */\n// eslint-disable-next-line @typescript-eslint/ban-types\nexport const isFunction = <T extends Function>(value: unknown): value is T =>\n  toString.call(value) === '[object Function]'\n\n/**\n * Checks if the passed-in value is a VueTypes type\n * @param value - The value to check\n */\nexport const isVueTypeDef = <T>(\n  value: any,\n): value is VueTypeDef<T> | VueTypeValidableDef<T> =>\n  isPlainObject(value) && has(value, '_vueTypes_name')\n\n/**\n * Checks if the passed-in value is a Vue prop definition object or a VueTypes type\n * @param value - The value to check\n */\nexport const isComplexType = <T>(value: any): value is VueProp<T> =>\n  isPlainObject(value) &&\n  (has(value, 'type') ||\n    ['_vueTypes_name', 'validator', 'default', 'required'].some((k) =>\n      has(value, k),\n    ))\n\nexport interface WrappedFn {\n  (...args: any[]): any\n  __original: (...args: any[]) => any\n}\n\n/**\n * Binds a function to a context and saves a reference to the original.\n *\n * @param fn - Target function\n * @param ctx - New function context\n */\nexport function bindTo(fn: (...args: any[]) => any, ctx: any): WrappedFn {\n  return Object.defineProperty(fn.bind(ctx) as WrappedFn, '__original', {\n    value: fn,\n  })\n}\n\n/**\n * Returns the original function bounded with `bindTo`. If the passed-in function\n * has not be bound, the function itself will be returned instead.\n *\n * @param fn - Function to unwrap\n */\n// eslint-disable-next-line @typescript-eslint/ban-types\nexport function unwrap<T extends WrappedFn | Function>(fn: T) {\n  return (fn as WrappedFn).__original ?? fn\n}\n\n/**\n * Validates a given value against a prop type object.\n *\n * If `silent` is `false` (default) will return a boolean. If it is set to `true`\n * it will return `true` on success or a string error message on failure\n *\n * @param {Object|*} type - Type to use for validation. Either a type object or a constructor\n * @param {*} value - Value to check\n * @param {boolean} silent - Silence warnings\n */\nexport function validateType<T, U>(\n  type: T,\n  value: U,\n  silent = false,\n): string | boolean {\n  let typeToCheck: { [key: string]: any }\n  let valid = true\n  let expectedType = ''\n  if (!isPlainObject(type)) {\n    typeToCheck = { type }\n  } else {\n    typeToCheck = type\n  }\n  const namePrefix = isVueTypeDef(typeToCheck)\n    ? typeToCheck._vueTypes_name + ' - '\n    : ''\n\n  if (isComplexType(typeToCheck) && typeToCheck.type !== null) {\n    if (typeToCheck.type === undefined || typeToCheck.type === true) {\n      return valid\n    }\n    if (!typeToCheck.required && value === undefined) {\n      return valid\n    }\n    if (isArray(typeToCheck.type)) {\n      valid = typeToCheck.type.some(\n        (type: any) => validateType(type, value, true) === true,\n      )\n      expectedType = typeToCheck.type\n        .map((type: any) => getType(type))\n        .join(' or ')\n    } else {\n      expectedType = getType(typeToCheck)\n\n      if (expectedType === 'Array') {\n        valid = isArray(value)\n      } else if (expectedType === 'Object') {\n        valid = isPlainObject(value)\n      } else if (\n        expectedType === 'String' ||\n        expectedType === 'Number' ||\n        expectedType === 'Boolean' ||\n        expectedType === 'Function'\n      ) {\n        valid = getNativeType(value) === expectedType\n      } else {\n        valid = value instanceof typeToCheck.type\n      }\n    }\n  }\n\n  if (!valid) {\n    const msg = `${namePrefix}value \"${value}\" should be of type \"${expectedType}\"`\n    if (silent === false) {\n      warn(msg)\n      return false\n    }\n    return msg\n  }\n\n  if (has(typeToCheck, 'validator') && isFunction(typeToCheck.validator)) {\n    const oldWarn = warn\n    const warnLog: string[] = []\n    warn = (msg) => {\n      warnLog.push(msg)\n    }\n\n    valid = typeToCheck.validator(value)\n    warn = oldWarn\n\n    if (!valid) {\n      const msg = (warnLog.length > 1 ? '* ' : '') + warnLog.join('\\n* ')\n      warnLog.length = 0\n      if (silent === false) {\n        warn(msg)\n        return valid\n      }\n      return msg\n    }\n  }\n  return valid\n}\n\n/**\n * Adds `isRequired` and `def` modifiers to an object\n *\n * @param {string} name - Type internal name\n * @param {object} obj - Object to enhance\n */\nexport function toType<T = any>(name: string, obj: PropOptions<T>) {\n  const type: VueTypeDef<T> = Object.defineProperties(obj as VueTypeDef<T>, {\n    _vueTypes_name: {\n      value: name,\n      writable: true,\n    },\n    isRequired: {\n      get() {\n        this.required = true\n        return this\n      },\n    },\n    def: {\n      value(def?: any) {\n        if (def === undefined) {\n          if (has(this, 'default')) {\n            delete this.default\n          }\n          return this\n        }\n        if (!isFunction(def) && validateType(this, def, true) !== true) {\n          warn(`${this._vueTypes_name} - invalid default value: \"${def}\"`)\n          return this\n        }\n        if (isArray(def)) {\n          this.default = () => [...def]\n        } else if (isPlainObject(def)) {\n          this.default = () => Object.assign({}, def)\n        } else {\n          this.default = def\n        }\n        return this\n      },\n    },\n  })\n\n  const { validator } = type\n  if (isFunction(validator)) {\n    type.validator = bindTo(validator, type)\n  }\n\n  return type\n}\n\n/**\n * Like `toType` but also adds the `validate()` method to the type object\n *\n * @param {string} name - Type internal name\n * @param {object} obj - Object to enhance\n */\nexport function toValidableType<T = any>(name: string, obj: PropOptions<T>) {\n  const type = toType<T>(name, obj)\n  return Object.defineProperty(type, 'validate', {\n    value(fn: (value: T) => boolean) {\n      if (isFunction(this.validator)) {\n        warn(\n          `${\n            this._vueTypes_name\n          } - calling .validate() will overwrite the current custom validator function. Validator info:\\n${JSON.stringify(\n            this,\n          )}`,\n        )\n      }\n      this.validator = bindTo(fn, this)\n      return this\n    },\n  }) as VueTypeValidableDef<T>\n}\n\n/**\n *  Clones an object preserving all of it's own keys.\n *\n * @param obj - Object to clone\n */\n// eslint-disable-next-line @typescript-eslint/ban-types\nexport function clone<T extends object>(obj: T): T {\n  const descriptors = {} as { [P in keyof T]: any }\n  Object.getOwnPropertyNames(obj).forEach((key) => {\n    descriptors[key as keyof T] = Object.getOwnPropertyDescriptor(obj, key)\n  })\n  return Object.defineProperties({}, descriptors) as T\n}\n\n/**\n * Return a new VueTypes type using another type as base.\n *\n * Properties in the `props` object will overwrite those defined in the source one\n * expect for the `validator` function. In that case both functions will be executed in series.\n *\n * @param name - Name of the new type\n * @param source - Source type\n * @param props - Custom type properties\n */\nexport function fromType<T extends VueTypeDef<any>>(name: string, source: T): T\nexport function fromType<\n  T extends VueTypeDef<any>,\n  V extends PropOptions<InferType<T>>,\n>(name: string, source: T, props: V): Omit<T, keyof V> & V\nexport function fromType<\n  T extends VueTypeDef<any>,\n  V extends PropOptions<InferType<T>>,\n>(name: string, source: T, props?: V) {\n  // 1. create an exact copy of the source type\n  const copy = clone(source)\n\n  // 2. give it a new name\n  copy._vueTypes_name = name\n\n  if (!isPlainObject(props)) {\n    return copy\n  }\n  const { validator, ...rest } = props\n\n  // 3. compose the validator function\n  // with the one on the source (if present)\n  // and ensure it is bound to the copy\n  if (isFunction(validator)) {\n    let { validator: prevValidator } = copy\n\n    if (prevValidator) {\n      prevValidator = unwrap(prevValidator) as (_v: any) => boolean\n    }\n\n    copy.validator = bindTo(\n      prevValidator\n        ? function (this: T, value: any) {\n            return (\n              // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n              prevValidator!.call(this, value) && validator.call(this, value)\n            )\n          }\n        : validator,\n      copy,\n    )\n  }\n  // 4. overwrite the rest, if present\n  return Object.assign(copy, rest as V)\n}\n\nexport function indent(string: string) {\n  return string.replace(/^(?!\\s*$)/gm, '  ')\n}\n","import { toType, toValidableType, isInteger } from '../utils'\nimport { PropType } from '../types'\n\nexport const any = <T = any>() => toValidableType<T>('any', {})\n\nexport const func = <T extends (...args: any[]) => any>() =>\n  toValidableType<T>('function', {\n    type: Function as PropType<T>,\n  })\n\nexport const bool = () =>\n  toValidableType('boolean', {\n    type: Boolean,\n  })\n\nexport const string = <T extends string = string>() =>\n  toValidableType<T>('string', {\n    type: String as unknown as PropType<T>,\n  })\n\nexport const number = <T extends number = number>() =>\n  toValidableType<T>('number', {\n    type: Number as unknown as PropType<T>,\n  })\n\nexport const array = <T>() =>\n  toValidableType<T[]>('array', {\n    type: Array,\n  })\n\nexport const object = <T extends { [key: string]: any }>() =>\n  toValidableType<T>('object', {\n    type: Object,\n  })\n\nexport const integer = <T extends number = number>() =>\n  toType<T>('integer', {\n    type: Number as unknown as PropType<T>,\n    validator(value) {\n      return isInteger(value)\n    },\n  })\n\nexport const symbol = () =>\n  toType<symbol>('symbol', {\n    validator(value) {\n      return typeof value === 'symbol'\n    },\n  })\n\nexport const nullable = () => ({\n  type: null as unknown as PropType<null>,\n})\n","import { toType, warn } from '../utils'\nimport { ValidatorFunction, VueTypeDef, PropType } from '../types'\n\nexport default function custom<T>(\n  validatorFn: ValidatorFunction<T>,\n  warnMsg = 'custom validation failed',\n) {\n  if (typeof validatorFn !== 'function') {\n    throw new TypeError(\n      '[VueTypes error]: You must provide a function as argument',\n    )\n  }\n\n  return toType<T>(validatorFn.name || '<<anonymous function>>', {\n    type: null as unknown as PropType<T>,\n    validator(this: VueTypeDef<T>, value: T) {\n      const valid = validatorFn(value)\n      if (!valid) warn(`${this._vueTypes_name} - ${warnMsg}`)\n      return valid\n    },\n  })\n}\n","import { Prop } from '../types'\nimport { toType, warn, isArray } from '../utils'\n\nexport default function oneOf<T extends readonly any[]>(arr: T) {\n  if (!isArray(arr)) {\n    throw new TypeError(\n      '[VueTypes error]: You must provide an array as argument.',\n    )\n  }\n  const msg = `oneOf - value should be one of \"${arr.join('\", \"')}\".`\n  const allowedTypes = arr.reduce((ret, v) => {\n    if (v !== null && v !== undefined) {\n      const constr = (v as any).constructor\n      ret.indexOf(constr) === -1 && ret.push(constr)\n    }\n    return ret\n  }, [] as Prop<T[number]>[])\n\n  return toType<T[number]>('oneOf', {\n    type: allowedTypes.length > 0 ? allowedTypes : undefined,\n    validator(value) {\n      const valid = arr.indexOf(value) !== -1\n      if (!valid) warn(msg)\n      return valid\n    },\n  })\n}\n","import { Prop, VueProp, InferType, PropType } from '../types'\nimport {\n  isArray,\n  isComplexType,\n  isVueTypeDef,\n  isFunction,\n  toType,\n  validateType,\n  warn,\n  indent,\n} from '../utils'\n\nexport default function oneOfType<\n  D extends V,\n  U extends VueProp<any> | Prop<any> = any,\n  V = InferType<U>,\n>(arr: U[]) {\n  if (!isArray(arr)) {\n    throw new TypeError(\n      '[VueTypes error]: You must provide an array as argument',\n    )\n  }\n\n  let hasCustomValidators = false\n\n  let nativeChecks: Prop<V>[] = []\n\n  for (let i = 0; i < arr.length; i += 1) {\n    const type = arr[i]\n    if (isComplexType<V>(type)) {\n      if (\n        isVueTypeDef<V>(type) &&\n        type._vueTypes_name === 'oneOf' &&\n        type.type\n      ) {\n        nativeChecks = nativeChecks.concat(type.type as PropType<V>)\n        continue\n      }\n      if (isFunction(type.validator)) {\n        hasCustomValidators = true\n      }\n      if (type.type === true || !type.type) {\n        warn('oneOfType - invalid usage of \"true\" or \"null\" as types.')\n        continue\n      } else {\n        nativeChecks = nativeChecks.concat(type.type)\n      }\n    } else {\n      nativeChecks.push(type as Prop<V>)\n    }\n  }\n\n  // filter duplicates\n  nativeChecks = nativeChecks.filter((t, i) => nativeChecks.indexOf(t) === i)\n\n  const typeProp = nativeChecks.length > 0 ? nativeChecks : null\n\n  if (!hasCustomValidators) {\n    // we got just native objects (ie: Array, Object)\n    // delegate to Vue native prop check\n    return toType<D>('oneOfType', {\n      type: typeProp as unknown as PropType<D>,\n    })\n  }\n\n  return toType<D>('oneOfType', {\n    type: typeProp as unknown as PropType<D>,\n    validator(value) {\n      const err: string[] = []\n      const valid = arr.some((type) => {\n        const t =\n          isVueTypeDef(type) && type._vueTypes_name === 'oneOf'\n            ? type.type || null\n            : type\n        const res = validateType(t, value, true)\n        if (typeof res === 'string') {\n          err.push(res)\n        }\n        return res === true\n      })\n      if (!valid) {\n        warn(\n          `oneOfType - provided value does not match any of the ${\n            err.length\n          } passed-in validators:\\n${indent(err.join('\\n'))}`,\n        )\n      }\n\n      return valid\n    },\n  })\n}\n","import { Prop, VueProp, InferType } from '../types'\nimport { toType, validateType, warn, indent } from '../utils'\n\nexport default function arrayOf<T extends VueProp<any> | Prop<any>>(type: T) {\n  return toType<InferType<T>[]>('arrayOf', {\n    type: Array,\n    validator(values: any[]) {\n      let vResult: string | boolean = ''\n      const valid = values.every((value) => {\n        vResult = validateType(type, value, true)\n        return vResult === true\n      })\n      if (!valid) {\n        warn(`arrayOf - value validation error:\\n${indent(vResult as string)}`)\n      }\n      return valid\n    },\n  })\n}\n","import { toType } from '../utils'\nimport { Constructor } from '../types'\n\nexport default function instanceOf<C extends Constructor>(\n  instanceConstructor: C,\n) {\n  return toType<InstanceType<C>>('instanceOf', {\n    type: instanceConstructor,\n  })\n}\n","import { Prop, VueProp, InferType } from '../types'\nimport { toType, validateType, warn, indent } from '../utils'\n\nexport default function objectOf<T extends VueProp<any> | Prop<any>>(type: T) {\n  return toType<{ [key: string]: InferType<T> }>('objectOf', {\n    type: Object,\n    validator(obj) {\n      let vResult: string | boolean = ''\n      const valid = Object.keys(obj).every((key) => {\n        vResult = validateType(type, obj[key], true)\n        return vResult === true\n      })\n\n      if (!valid) {\n        warn(`objectOf - value validation error:\\n${indent(vResult as string)}`)\n      }\n      return valid\n    },\n  })\n}\n","import { Prop, VueProp, VueTypeShape, VueTypeLooseShape } from '../types'\nimport { toType, validateType, warn, isPlainObject, indent } from '../utils'\n\n// eslint-disable-next-line @typescript-eslint/ban-types\nexport default function shape<T extends object>(obj: {\n  [K in keyof T]: Prop<T[K]> | VueProp<T[K]>\n}): VueTypeShape<T> {\n  const keys = Object.keys(obj)\n  const requiredKeys = keys.filter((key) => !!(obj as any)[key]?.required)\n\n  const type = toType('shape', {\n    type: Object,\n    validator(this: VueTypeShape<T> | VueTypeLooseShape<T>, value) {\n      if (!isPlainObject(value)) {\n        return false\n      }\n      const valueKeys = Object.keys(value)\n\n      // check for required keys (if any)\n      if (\n        requiredKeys.length > 0 &&\n        requiredKeys.some((req) => valueKeys.indexOf(req) === -1)\n      ) {\n        const missing = requiredKeys.filter(\n          (req) => valueKeys.indexOf(req) === -1,\n        )\n        if (missing.length === 1) {\n          warn(`shape - required property \"${missing[0]}\" is not defined.`)\n        } else {\n          warn(\n            `shape - required properties \"${missing.join(\n              '\", \"',\n            )}\" are not defined.`,\n          )\n        }\n\n        return false\n      }\n\n      return valueKeys.every((key) => {\n        if (keys.indexOf(key) === -1) {\n          if ((this as VueTypeLooseShape<T>)._vueTypes_isLoose === true)\n            return true\n          warn(\n            `shape - shape definition does not include a \"${key}\" property. Allowed keys: \"${keys.join(\n              '\", \"',\n            )}\".`,\n          )\n          return false\n        }\n        const type = (obj as any)[key]\n        const valid = validateType(type, value[key], true)\n        if (typeof valid === 'string') {\n          warn(`shape - \"${key}\" property validation error:\\n ${indent(valid)}`)\n        }\n        return valid === true\n      })\n    },\n  }) as VueTypeShape<T>\n\n  Object.defineProperty(type, '_vueTypes_isLoose', {\n    writable: true,\n    value: false,\n  })\n\n  Object.defineProperty(type, 'loose', {\n    get() {\n      this._vueTypes_isLoose = true\n      return this\n    },\n  })\n\n  return type\n}\n","import {\n  toType,\n  toValidableType,\n  validateType,\n  isArray,\n  isVueTypeDef,\n  has,\n  fromType,\n} from './utils'\n\nimport {\n  VueTypesDefaults,\n  ExtendProps,\n  VueTypeDef,\n  VueTypeValidableDef,\n  VueTypeShape,\n  VueTypeLooseShape,\n} from './types'\nimport { typeDefaults } from './sensibles'\nimport { PropOptions } from './types'\n\nimport {\n  any,\n  func,\n  bool,\n  string,\n  number,\n  array,\n  integer,\n  symbol,\n  object,\n  nullable,\n} from './validators/native'\nimport custom from './validators/custom'\nimport oneOf from './validators/oneof'\nimport oneOfType from './validators/oneoftype'\nimport arrayOf from './validators/arrayof'\nimport instanceOf from './validators/instanceof'\nimport objectOf from './validators/objectof'\nimport shape from './validators/shape'\nimport { config } from './config'\n\nconst BaseVueTypes = /*#__PURE__*/ (() =>\n  class BaseVueTypes {\n    static defaults: Partial<VueTypesDefaults> = {}\n\n    static sensibleDefaults: Partial<VueTypesDefaults> | boolean\n\n    static config = config\n\n    static get any() {\n      return any()\n    }\n    static get func() {\n      return func().def(this.defaults.func)\n    }\n    static get bool() {\n      return bool().def(this.defaults.bool)\n    }\n    static get string() {\n      return string().def(this.defaults.string)\n    }\n    static get number() {\n      return number().def(this.defaults.number)\n    }\n    static get array() {\n      return array().def(this.defaults.array)\n    }\n    static get object() {\n      return object().def(this.defaults.object)\n    }\n    static get integer() {\n      return integer().def(this.defaults.integer)\n    }\n    static get symbol() {\n      return symbol()\n    }\n\n    static get nullable() {\n      return nullable()\n    }\n\n    static readonly custom = custom\n    static readonly oneOf = oneOf\n    static readonly instanceOf = instanceOf\n    static readonly oneOfType = oneOfType\n    static readonly arrayOf = arrayOf\n    static readonly objectOf = objectOf\n    static readonly shape = shape\n\n    static extend<T extends typeof BaseVueTypes>(\n      props: ExtendProps | ExtendProps[],\n    ): T {\n      if (isArray(props)) {\n        props.forEach((p) => this.extend(p))\n        return this as any\n      }\n\n      const { name, validate = false, getter = false, ...opts } = props\n\n      if (has(this, name as any)) {\n        throw new TypeError(`[VueTypes error]: Type \"${name}\" already defined`)\n      }\n\n      const { type } = opts\n      if (isVueTypeDef(type)) {\n        // we are using as base type a vue-type object\n\n        // detach the original type\n        // we are going to inherit the parent data.\n        delete opts.type\n\n        if (getter) {\n          return Object.defineProperty(this as T, name, {\n            get: () => fromType(name, type, opts as Omit<ExtendProps, 'type'>),\n          })\n        }\n        return Object.defineProperty(this as T, name, {\n          value(...args: unknown[]) {\n            const t = fromType(name, type, opts as Omit<ExtendProps, 'type'>)\n            if (t.validator) {\n              t.validator = t.validator.bind(t, ...args)\n            }\n            return t\n          },\n        })\n      }\n\n      let descriptor: PropertyDescriptor\n      if (getter) {\n        descriptor = {\n          get() {\n            const typeOptions = Object.assign({}, opts as PropOptions<T>)\n            if (validate) {\n              return toValidableType<T>(name, typeOptions)\n            }\n            return toType<T>(name, typeOptions)\n          },\n          enumerable: true,\n        }\n      } else {\n        descriptor = {\n          value(...args: T[]) {\n            const typeOptions = Object.assign({}, opts as PropOptions<T>)\n            let ret: VueTypeDef<T>\n            if (validate) {\n              ret = toValidableType<T>(name, typeOptions)\n            } else {\n              ret = toType<T>(name, typeOptions)\n            }\n\n            if (typeOptions.validator) {\n              ret.validator = typeOptions.validator.bind(ret, ...args)\n            }\n            return ret\n          },\n          enumerable: true,\n        }\n      }\n\n      return Object.defineProperty(this as T, name, descriptor)\n    }\n\n    static utils = {\n      validate<T, U>(value: T, type: U) {\n        return validateType<U, T>(type, value, true) === true\n      },\n      toType<T = unknown>(\n        name: string,\n        obj: PropOptions<T>,\n        validable = false,\n      ): VueTypeDef<T> | VueTypeValidableDef<T> {\n        return validable ? toValidableType<T>(name, obj) : toType<T>(name, obj)\n      },\n    }\n  })()\n\nfunction createTypes(defs: Partial<VueTypesDefaults> = typeDefaults()) {\n  return class extends BaseVueTypes {\n    static defaults: Partial<VueTypesDefaults> = { ...defs }\n\n    static get sensibleDefaults() {\n      return { ...this.defaults }\n    }\n\n    static set sensibleDefaults(v: boolean | Partial<VueTypesDefaults>) {\n      if (v === false) {\n        this.defaults = {}\n        return\n      }\n      if (v === true) {\n        this.defaults = { ...defs }\n        return\n      }\n      this.defaults = { ...v }\n    }\n  }\n}\n\nexport default class VueTypes /*#__PURE__*/ extends createTypes() {}\n\nexport {\n  any,\n  func,\n  bool,\n  string,\n  number,\n  array,\n  integer,\n  symbol,\n  object,\n  custom,\n  oneOf,\n  oneOfType,\n  arrayOf,\n  instanceOf,\n  objectOf,\n  shape,\n  nullable,\n  createTypes,\n  toType,\n  toValidableType,\n  validateType,\n  fromType,\n  config,\n}\n\nexport type VueTypesInterface = ReturnType<typeof createTypes>\nexport type { VueTypeDef, VueTypeValidableDef, VueTypeShape, VueTypeLooseShape }\n","import { VueTypesDefaults } from './types'\n\nexport const typeDefaults = (): VueTypesDefaults => ({\n  func: () => undefined,\n  bool: true,\n  string: '',\n  number: 0,\n  array: () => [],\n  object: () => ({}),\n  integer: 0,\n})\n"],"mappings":";;;;;;;;;;;;;;;;;;;;AAEa,MAAMA,CAAA,GAAmB;IACpCC,MAAA,GAAQ;IACRC,QAAA,EAAU;EAAA;ECJZC,CAAA;EAUcC,CAAA,GAAGC,MAAA,CAAOC,SAAA;EACVC,CAAA,GAAGH,CAAA,CAASI,QAAA;EACbC,CAAA,GAASL,CAAA,CAASM,cAAA;EAEVC,CAAA,GAAG;AAGlB,SAAAC,EACJC,CAAA;EAA8D,IAAAC,CAAA;EAE9D,MAAMC,CAAA,GAAqC,UAAAD,CAAA,GAA7B,QAAAD,CAAA,QAAJ,IAAIA,CAAA,CAAqBG,IAAA,UAAQ,MAAAF,CAAA,GAAAA,CAAA,GAAAD,CAAA;EAC3C,IAAIE,CAAA,EAAM;IACR,MAAMF,CAAA,GAAQE,CAAA,CAAKP,QAAA,GAAWS,KAAA,CAAMN,CAAA;IACpC,OAAOE,CAAA,GAAQA,CAAA,CAAM,KAAK,EAC3B;EAAA;EACD,OAAO,EACR;AAAA;AASY,MAAAK,CAAA,GAAgBL,CAAA;EAahBM,CAAA,GAAYN,CAAA,IAAaA,CAAA;AAEtC,IAAIO,CAAA,GAAuCD,CAAA;AAE3C,IAA6B,iBAAzBE,OAAA,CAAQC,GAAA,CAAIC,QAAA,EAA2B;EACzC,MAAAV,CAAA,GAAsC,sBAAnBW,OAAA;EACnBJ,CAAA,GAAOP,CAAA,GACH,UAAcA,CAAA,EAAaC,CAAA,GAAQd,CAAA,CAAOE,QAAA;IAAA,CAClB,MAAlBF,CAAA,CAAOC,MAAA,IACTuB,OAAA,CAAQV,CAAA,sBAA2BD,CAAA,GAEtC;EAAA,IACDM,CACL;AAAA;AAUM,MAASM,CAAA,GAAGC,CAAuBb,CAAA,EAAQC,CAAA,KAChDL,CAAA,CAAOkB,IAAA,CAAKd,CAAA,EAAKC,CAAA;EASNc,CAAA,GACXC,MAAA,CAAOC,SAAA,IACP,UAAmBjB,CAAA;IACjB,OACmB,mBAAVA,CAAA,IACPkB,QAAA,CAASlB,CAAA,KACTmB,IAAA,CAAKC,KAAA,CAAMpB,CAAA,MAAWA,CAEzB;EAAA;EAQiBqB,CAAA,GAClBC,KAAA,CAAMC,OAAA,IACN,UAAiBvB,CAAA;IACf,OAAgC,qBAAjBN,CAAA,CAACoB,IAAA,CAAKd,CAAA,CACtB;EAAA;EASUwB,CAAA,GAAkCxB,CAAA,IACpB,wBAAzBN,CAAA,CAASoB,IAAA,CAAKd,CAAA;EAMHyB,CAAA,GACXzB,CAAA,IAEAK,CAAA,CAAcL,CAAA,KAAUY,CAAA,CAAIZ,CAAA,EAAO;EAMX0B,CAAA,GAAO1B,CAAA,IAC/BK,CAAA,CAAcL,CAAA,MACbY,CAAA,CAAIZ,CAAA,EAAO,WACV,CAAC,kBAAkB,aAAa,WAAW,YAAY2B,IAAA,CAAM1B,CAAA,IAC3DW,CAAA,CAAIZ,CAAA,EAAOC,CAAA;AAcD,SAAA2B,EAAO5B,CAAA,EAA6BC,CAAA;EAClD,OAAaT,MAAA,CAACqC,cAAA,CAAe7B,CAAA,CAAG8B,IAAA,CAAK7B,CAAA,GAAmB,cAAc;IACpE8B,KAAA,EAAO/B;EAAA,EAEV;AAAA;AAuBe,SAAAgC,EACdhC,CAAA,EACAC,CAAA,EACAC,CAAA,IAAS;EAET,IAAIf,CAAA;IAAAG,CAAA,IACQ;IAAAC,CAAA,GACO;EAIjBJ,CAAA,GAHGkB,CAAA,CAAcL,CAAA,IAGHA,CAAA,GAFA;IAAEG,IAAA,EAAAH;EAAA;EAIlB,MAAAN,CAAA,GAAmB+B,CAAA,CAAatC,CAAA,IAC5BA,CAAA,CAAY8C,cAAA,GAAiB,QAC7B;EAEJ,IAAIP,CAAA,CAAcvC,CAAA,KAAqC,SAArBA,CAAA,CAAYgB,IAAA,EAAe;IAC3D,SAAyB,MAArBhB,CAAA,CAAYgB,IAAA,KAA2C,MAArBhB,CAAA,CAAYgB,IAAA,EAChD,OACDb,CAAA;IACD,KAAKH,CAAA,CAAY+C,QAAA,SAAsB,MAAVjC,CAAA,EAC3B,OAAAX,CAAA;IAEE+B,CAAA,CAAQlC,CAAA,CAAYgB,IAAA,KACtBb,CAAA,GAAQH,CAAA,CAAYgB,IAAA,CAAKwB,IAAA,CACtB3B,CAAA,KAAkD,MAApCgC,CAAA,CAAahC,CAAA,EAAMC,CAAA,GAAO,KAE3CV,CAAA,GAAeJ,CAAA,CAAYgB,IAAA,CACxBgC,GAAA,CAAKnC,CAAA,IAAcD,CAAA,CAAQC,CAAA,GAC3BoC,IAAA,CAAK,YAER7C,CAAA,GAAeQ,CAAA,CAAQZ,CAAA,GAGrBG,CAAA,GADmB,YAAjBC,CAAA,GACM8B,CAAA,CAAQpB,CAAA,IACU,aAAjBV,CAAA,GACDc,CAAA,CAAcJ,CAAA,IAEL,aAAjBV,CAAA,IACiB,aAAjBA,CAAA,IACiB,cAAjBA,CAAA,IACiB,eAAjBA,CAAA,GAzLQ,UAAcS,CAAA;MAC5B,IAAI,QAAAA,CAAA,EAAuC,OAAO;MAClD,MAAWC,CAAA,GAAGD,CAAA,CAAMqC,WAAA,CAAY1C,QAAA,GAAWS,KAAA,CAAMN,CAAA;MACjD,OAAYG,CAAA,GAAGA,CAAA,CAAM,KAAK,EAC3B;IAAA,CAuLe,CAAcA,CAAA,MAAWV,CAAA,GAEzBU,CAAA,YAAiBd,CAAA,CAAYgB,IAAA,CAG1C;EAAA;EAED,KAAKb,CAAA,EAAO;IACV,MAASU,CAAA,GAAM,GAAAN,CAAA,UAAoBO,CAAA,wBAA6BV,CAAA;IAChE,QAAe,MAAXW,CAAA,IACFK,CAAA,CAAKP,CAAA,IACE,KAGVA,CAAA;EAAA;EAED,IAAIY,CAAA,CAAIzB,CAAA,EAAa,gBAAgBqC,CAAA,CAAWrC,CAAA,CAAYmD,SAAA,GAAY;IACtE,MAAatC,CAAA,GAAGO,CAAA;MACHhB,CAAA,GAAa;IAQ1B,IAPAgB,CAAA,GAAQP,CAAA;MACNT,CAAA,CAAQgD,IAAA,CAAKvC,CAAA;IAAA,GAGfV,CAAA,GAAQH,CAAA,CAAYmD,SAAA,CAAUrC,CAAA,GAC9BM,CAAA,GAAOP,CAAA,GAEFV,CAAA,EAAO;MACV,MAASU,CAAA,IAAIT,CAAA,CAAQiD,MAAA,GAAS,IAAI,OAAO,MAAMjD,CAAA,CAAQ6C,IAAA,CAAK;MAE5D,OADA7C,CAAA,CAAQiD,MAAA,GAAS,IACF,MAAXtC,CAAA,IACFK,CAAA,CAAKP,CAAA,GAENV,CAAA,IACMU,CACR;IAAA;EACF;EACD,OACDV,CAAA;AAAA;AAQe,SAAAmD,EAAgBzC,CAAA,EAAcC,CAAA;EAC5C,MAAUC,CAAA,GAAkBV,MAAA,CAAOkD,gBAAA,CAAiBzC,CAAA,EAAsB;MACxEgC,cAAA,EAAgB;QACdF,KAAA,EAAO/B,CAAA;QACP2C,QAAA,GAAU;MAAA;MAEZC,UAAA,EAAY;QACVC,IAAA;UAEE,OADA,KAAKX,QAAA,IAAW,GAEjB;QAAA;MAAA;MAEHY,GAAA,EAAK;QACHf,MAAM/B,CAAA;UACJ,YAAY,MAARA,CAAA,IACEY,CAAA,CAAI,MAAM,0BACAmC,OAAA,EAEP,QAEJvB,CAAA,CAAWxB,CAAA,MAA0C,MAAlCgC,CAAA,CAAa,MAAMhC,CAAA,GAAK,MAK9C,KAAK+C,OAAA,GADH1B,CAAA,CAAQrB,CAAA,IACK,MAAM,IAAIA,CAAA,IAChBK,CAAA,CAAcL,CAAA,IACR,MAAMR,MAAA,CAAOwD,MAAA,CAAO,CAAd,GAAkBhD,CAAA,IAExBA,CAAA,EAGlB,SAXGO,CAAA,IAAQ,KAAK0B,cAAA,8BAA4CjC,CAAA,MAE1D,KASF;QAAA;MAAA;IAAA;IAAA;MAICsC,SAAA,EAAEnD;IAAA,IAAce,CAAA;EAKtB,OAJIsB,CAAA,CAAWrC,CAAA,MACbe,CAAA,CAAKoC,SAAA,GAAYV,CAAA,CAAOzC,CAAA,EAAWe,CAAA,IAG9BA,CACR;AAAA;AAQe,SAAA+C,EAAyBjD,CAAA,EAAcC,CAAA;EACrD,MAAMC,CAAA,GAAOuC,CAAA,CAAUzC,CAAA,EAAMC,CAAA;EAC7B,OAAOT,MAAA,CAAOqC,cAAA,CAAe3B,CAAA,EAAM,YAAY;IAC7C6B,MAAM/B,CAAA;MAWJ,OAVIwB,CAAA,CAAW,KAAKc,SAAA,KAClB/B,CAAA,CACE,GACE,KAAK0B,cAAA,iGAC0FiB,IAAA,CAAKC,SAAA,CACpG,UAIN,KAAKb,SAAA,GAAYV,CAAA,CAAO5B,CAAA,EAAI,OAE7B;IAAA;EAAA,EAEJ;AAAA;AA+Be,SAAAoD,EAGdpD,CAAA,EAAcC,CAAA,EAAWd,CAAA;EAEzB,MAAAI,CAAA,GA5BI,UAAkCS,CAAA;IACtC,MAAiBC,CAAA,GAAG;IAIpB,OAHAT,MAAA,CAAO6D,mBAAA,CAAoBrD,CAAA,EAAKsD,OAAA,CAASpD,CAAA;MACvCD,CAAA,CAAYC,CAAA,IAAkBV,MAAA,CAAO+D,wBAAA,CAAyBvD,CAAA,EAAKE,CAAA,CACpE;IAAA,IACYV,MAAA,CAACkD,gBAAA,CAAiB,IAAIzC,CAAA,CACpC;EAAA,CAsBc,CAAMA,CAAA;EAKnB,IAFAV,CAAA,CAAK0C,cAAA,GAAiBjC,CAAA,GAEjBK,CAAA,CAAclB,CAAA,GACjB,OACDI,CAAA;EACD;MAAM+C,SAAA,EAAE5C;IAAA,IAAuBP,CAAA;IAATS,CAAA,GAASM,CAAA,CAAAf,CAAA,EAAAG,CAAA;EAK/B,IAAIkC,CAAA,CAAW9B,CAAA,GAAY;IACzB;MAAM4C,SAAA,EAAWtC;IAAA,IAAkBT,CAAA;IAE/BS,CAAA,KACFA,CAAA,GA9NJ,UAAAD,CAAA,IADqDD,CAAA,GA+N1BE,CAAA,EA9NFwD,UAAA,UAAzB,MAAAzD,CAAA,GAAAA,CAAA,GAAuCD,CAAA,GAiOrCP,CAAA,CAAK+C,SAAA,GAAYV,CAAA,CACf5B,CAAA,GACI,UAAmBC,CAAA;MACjB,OAEED,CAAA,CAAec,IAAA,CAAK,MAAMb,CAAA,KAAUP,CAAA,CAAUoB,IAAA,CAAK,MAAMb,CAAA,CAE5D;IAAA,IACDP,CAAA,EACJH,CAAA,CAEH;EAAA;EA7Oa,IAAuCO,CAAA,EACrDC,CAAA;EA8OA,OAAOP,MAAA,CAAOwD,MAAA,CAAOzD,CAAA,EAAMK,CAAA,CAC5B;AAAA;AAEK,SAAA6D,EAAiBzD,CAAA;EACrB,OAAOA,CAAA,CAAO0D,OAAA,CAAQ,eAAe,KACtC;AAAA;AAAA,MC9YYC,CAAA,GAAMC,CAAA,KAAeX,CAAA,CAAmB,OAAO,CAAX;EAAAY,CAAA,GAE7BA,CAAA,KAClBZ,CAAA,CAAmB,YAAY;IAC7B9C,IAAA,EAAM2D;EAAA;EAGOC,CAAA,GAAGC,CAAA,KAClBf,CAAA,CAAgB,WAAW;IACzB9C,IAAA,EAAM8D;EAAA;EAAAC,CAAA,GAGYD,CAAA,KACpBhB,CAAA,CAAmB,UAAU;IAC3B9C,IAAA,EAAMgE;EAAA;EAGGC,CAAA,GAASC,CAAA,KACpBpB,CAAA,CAAmB,UAAU;IAC3B9C,IAAA,EAAMa;EAAA;EAAAsD,CAAA,GAGWtD,CAAA,KACnBiC,CAAA,CAAqB,SAAS;IAC5B9C,IAAA,EAAMmB;EAAA;EAAAiD,CAAA,GAGYjD,CAAA,KACpB2B,CAAA,CAAmB,UAAU;IAC3B9C,IAAA,EAAMX;EAAA;EAGGgF,CAAA,GAAUC,CAAA,KACrBhC,CAAA,CAAU,WAAW;IACnBtC,IAAA,EAAMa,MAAA;IACNsB,SAAA,EAAUtC,CAAA,IAAAe,CAAA,CACSf,CAAA;EAAA;EAIJ0E,CAAA,GAAGC,CAAA,KACpBlC,CAAA,CAAe,UAAU;IACvBH,SAAA,EAAUtC,CAAA,IACgB,mBAAVA;EAAA;EAIP4E,CAAA,GAAWC,CAAA,MAAO;IAC7B1E,IAAA,EAAM;EAAA;AChDgB,SAAA2E,EACtB9E,CAAA,EACAC,CAAA,GAAU;EAEV,IAA2B,qBAAhBD,CAAA,EACT,UAAM+E,SAAA,CACJ;EAIJ,OAAOtC,CAAA,CAAUzC,CAAA,CAAYgF,IAAA,IAAQ,0BAA0B;IAC7D7E,IAAA,EAAM;IACNmC,UAA+BpC,CAAA;MAC7B,MAAWf,CAAA,GAAGa,CAAA,CAAYE,CAAA;MAE1B,OADKf,CAAA,IAAOoB,CAAA,IAAQ,KAAK0B,cAAA,MAAoBhC,CAAA,KAE9Cd,CAAA;IAAA;EAAA,EAEJ;AAAA;AClBuB,SAAA8F,EAAgCjF,CAAA;EACtD,KAAKqB,CAAA,CAAQrB,CAAA,GACX,MAAM,IAAA+E,SAAA,CACJ;EAGJ,MAAA9E,CAAA,GAAY,mCAAmCD,CAAA,CAAIoC,IAAA,CAAK;IACtClC,CAAA,GAAGF,CAAA,CAAIkF,MAAA,CAAO,CAAClF,CAAA,EAAKC,CAAA;MACpC,IAAI,QAAAA,CAAA,EAA+B;QACjC,MAAYC,CAAA,GAAID,CAAA,CAAUoC,WAAA;QAAA,CACD,MAAzBrC,CAAA,CAAImF,OAAA,CAAQjF,CAAA,KAAkBF,CAAA,CAAIuC,IAAA,CAAKrC,CAAA,CACxC;MAAA;MACD,OACDF,CAAA;IAAA,GAAE;EAEH,OAAayC,CAAA,CAAY,SAAS;IAChCtC,IAAA,EAAMD,CAAA,CAAasC,MAAA,GAAS,IAAItC,CAAA,QAAe;IAC/CoC,UAAUpC,CAAA;MACR,MAAWf,CAAA,IAA2B,MAAxBa,CAAA,CAAImF,OAAA,CAAQjF,CAAA;MAE1B,OADKf,CAAA,IAAOoB,CAAA,CAAKN,CAAA,GAElBd,CAAA;IAAA;EAAA,EAEJ;AAAA;ACduB,SAAAiG,EAItBpF,CAAA;EACA,KAAKqB,CAAA,CAAQrB,CAAA,GACX,UAAM+E,SAAA,CACJ;EAIJ,IAAI9E,CAAA,IAAsB;IAEtBC,CAAA,GAA0B;EAE9B,KAAK,IAAAf,CAAA,GAAQ,GAAGA,CAAA,GAAIa,CAAA,CAAIwC,MAAA,EAAQrD,CAAA,IAAK,GAAG;IACtC,MAAAG,CAAA,GAAaU,CAAA,CAAIb,CAAA;IACjB,IAAIuC,CAAA,CAAiBpC,CAAA,GAAO;MAC1B,IACEmC,CAAA,CAAgBnC,CAAA,KACQ,YAAxBA,CAAA,CAAK2C,cAAA,IACL3C,CAAA,CAAKa,IAAA,EACL;QACAD,CAAA,GAAeA,CAAA,CAAamF,MAAA,CAAO/F,CAAA,CAAKa,IAAA;QACxC;MACD;MAID,IAHIqB,CAAA,CAAWlC,CAAA,CAAKgD,SAAA,MAClBrC,CAAA,IAAsB,KAEN,MAAdX,CAAA,CAAKa,IAAA,KAAkBb,CAAA,CAAKa,IAAA,EAAM;QACpCI,CAAA,CAAK;QACL;MACD;MACCL,CAAA,GAAeA,CAAA,CAAamF,MAAA,CAAO/F,CAAA,CAAKa,IAAA,CAE3C;IAAA,OACCD,CAAA,CAAaqC,IAAA,CAAKjD,CAAA,CAErB;EAAA;EAGDY,CAAA,GAAeA,CAAA,CAAaoF,MAAA,CAAO,CAACtF,CAAA,EAAGC,CAAA,KAAMC,CAAA,CAAaiF,OAAA,CAAQnF,CAAA,MAAOC,CAAA;EAEzE,MAAcd,CAAA,GAAGe,CAAA,CAAasC,MAAA,GAAS,IAAItC,CAAA,GAAe;EAE1D,OAAAuC,CAAA,CAQiB,aARZxC,CAAA,GAQyB;IAC5BE,IAAA,EAAMhB,CAAA;IACNmD,UAAUrC,CAAA;MACR,MAAMC,CAAA,GAAgB;QAChBf,CAAA,GAAQa,CAAA,CAAI2B,IAAA,CAAM3B,CAAA;UACtB,MAIMb,CAAA,GAAM6C,CAAA,CAHVP,CAAA,CAAazB,CAAA,KAAiC,YAAxBA,CAAA,CAAKiC,cAAA,GACvBjC,CAAA,CAAKG,IAAA,IAAQ,OACbH,CAAA,EACsBC,CAAA,GAAO;UAInC,OAHmB,mBAARd,CAAA,IACTe,CAAA,CAAIqC,IAAA,CAAKpD,CAAA,IAEI,MAARA,CAAQ;QAAA;MAUjB,OARKA,CAAA,IACHoB,CAAA,CAEI,wDAAAL,CAAA,CAAIsC,MAAA,2BACqBiB,CAAA,CAAOvD,CAAA,CAAIkC,IAAA,CAAK,WAKhDjD,CAAA;IAAA;EAAA,IA7B6B;IAC5BgB,IAAA,EAAMhB;EAAA,EA8BX;AAAA;AAAA,SCxFuBoG,EAA4CvF,CAAA;EAClE,OAAayC,CAAA,CAAiB,WAAW;IACvCtC,IAAA,EAAMmB,KAAA;IACNgB,UAAUrC,CAAA;MACR,IAAAC,CAAA,GAAgC;MAChC,MAAMf,CAAA,GAAQc,CAAA,CAAOuF,KAAA,CAAOvF,CAAA,KAC1BC,CAAA,GAAU8B,CAAA,CAAahC,CAAA,EAAMC,CAAA,GAAO,KACjB,MAALC,CAAA;MAKhB,OAHKf,CAAA,IACHoB,CAAA,uCAA2CkD,CAAA,CAAOvD,CAAA,MAGrDf,CAAA;IAAA;EAAA,EAEJ;AAAA;ACfuB,SAAAsG,EACtBzF,CAAA;EAEA,OAAOyC,CAAA,CAAwB,cAAc;IAC3CtC,IAAA,EAAMH;EAAA,EAET;AAAA;ACNuB,SAAA0F,EAA6C1F,CAAA;EACnE,OAAAyC,CAAA,CAA+C,YAAY;IACzDtC,IAAA,EAAMX,MAAA;IACN8C,UAAUrC,CAAA;MACR,IAAAC,CAAA,GAAgC;MAChC,MAAMf,CAAA,GAAQK,MAAA,CAAOmG,IAAA,CAAK1F,CAAA,EAAKuF,KAAA,CAAOrG,CAAA,KACpCe,CAAA,GAAU8B,CAAA,CAAahC,CAAA,EAAMC,CAAA,CAAId,CAAA,IAAM,KACpB,MAAAe,CAAA;MAMrB,OAHKf,CAAA,IACHoB,CAAA,wCAA4CkD,CAAA,CAAOvD,CAAA,MAGtDf,CAAA;IAAA;EAAA,EAEJ;AAAA;ACfuB,SAAAyG,EAAwB5F,CAAA;EAG9C,MAAMC,CAAA,GAAOT,MAAA,CAAOmG,IAAA,CAAK3F,CAAA;IACnBE,CAAA,GAAeD,CAAA,CAAKqF,MAAA,CAAQrF,CAAA;MAAD,IAAAC,CAAA;MAAA,SAAU,UAAAA,CAAA,GAAEF,CAAA,CAAYC,CAAA,WAAd,MAAAC,CAAA,KAAEA,CAAA,CAAkBgC,QAAA,CAApB;IAAA;IAAA/C,CAAA,GAE9BsD,CAAA,CAAO,SAAS;MAC3BtC,IAAA,EAAMX,MAAA;MACN8C,UAAwDnD,CAAA;QACtD,KAAKkB,CAAA,CAAclB,CAAA,GACjB,QACD;QACD,MAAMG,CAAA,GAAYE,MAAA,CAAOmG,IAAA,CAAKxG,CAAA;QAG9B,IACEe,CAAA,CAAasC,MAAA,GAAS,KACtBtC,CAAA,CAAayB,IAAA,CAAM3B,CAAA,KAAoC,MAA5BV,CAAA,CAAU6F,OAAA,CAAQnF,CAAA,IAC7C;UACA,MAAMA,CAAA,GAAUE,CAAA,CAAaoF,MAAA,CAC1BtF,CAAA,KAAoC,MAA5BV,CAAA,CAAU6F,OAAA,CAAQnF,CAAA;UAY7B,OATEO,CAAA,CADqB,MAAnBP,CAAA,CAAQwC,MAAA,iCACyBxC,CAAA,CAAQ,wBAGT,gCAAAA,CAAA,CAAQoC,IAAA,CACtC,+BAKC,CACR;QAAA;QAED,OAAA9C,CAAA,CAAiBkG,KAAA,CAAOtF,CAAA;UACtB,KAA2B,MAAvBD,CAAA,CAAKkF,OAAA,CAAQjF,CAAA,GACf,QAAyD,MAApD,KAA8B2F,iBAAA,KAEnCtF,CAAA,CACE,gDAAgDL,CAAA,8BAAiCD,CAAA,CAAKmC,IAAA,CACpF,eAGG;UAET,MAAA9C,CAAA,GACc0C,CAAA,CADAhC,CAAA,CAAYE,CAAA,GACOf,CAAA,CAAMe,CAAA,IAAM;UAI7C,OAHqB,mBAAVZ,CAAA,IACTiB,CAAA,CAAiB,YAAAL,CAAA,kCAAqCuD,CAAA,CAAOnE,CAAA,OAE9C,MAAAA,CAAA;QAAA,EAEpB;MAAA;IAAA;EAeH,OAZAE,MAAA,CAAOqC,cAAA,CAAe1C,CAAA,EAAM,qBAAqB;IAC/CwD,QAAA,GAAU;IACVZ,KAAA,GAAO;EAAA,IAGTvC,MAAA,CAAOqC,cAAA,CAAe1C,CAAA,EAAM,SAAS;IACnC0D,IAAA;MAEE,OADA,KAAKgD,iBAAA,IAAoB,GAE1B;IAAA;EAAA,IAIJ1G,CAAA;AAAA;ACzED,MAAA2G,CAAA;EA0CMC,CAAA,gBAA6B;IAAA,IAAA/F,CAAA;IAAA,QAAAA,CAAA,GACjC;MAAA,WAAA4D,IAAA;QAQI,OAAUD,CAAA,EACX;MAAA;MACU,WAAAqC,KAAA;QACT,OAAAnC,CAAA,GAAcf,GAAA,CAAI,KAAKmD,QAAA,CAASD,IAAA,CACjC;MAAA;MACU,WAAAhC,KAAA;QACT,OAAAD,CAAA,GAAcjB,GAAA,CAAI,KAAKmD,QAAA,CAASjC,IAAA,CACjC;MAAA;MACU,WAAAkC,OAAA;QACT,OAAAhC,CAAA,GAAgBpB,GAAA,CAAI,KAAKmD,QAAA,CAASC,MAAA,CACnC;MAAA;MAAA,WAAA7B,OAAA;QAEC,OAAaD,CAAA,GAAGtB,GAAA,CAAI,KAAKmD,QAAA,CAAS5B,MAAA,CACnC;MAAA;MAAA,WAAA8B,MAAA;QAEC,OAAY7B,CAAA,GAAGxB,GAAA,CAAI,KAAKmD,QAAA,CAASE,KAAA,CAClC;MAAA;MAAA,WAAAC,OAAA;QAEC,OAAa7B,CAAA,GAAGzB,GAAA,CAAI,KAAKmD,QAAA,CAASG,MAAA,CACnC;MAAA;MACiB,WAAA3B,QAAA;QAChB,OAAOD,CAAA,GAAU1B,GAAA,CAAI,KAAKmD,QAAA,CAASxB,OAAA,CACpC;MAAA;MACgB,WAAAE,OAAA;QACf,OAAOD,CAAA,EACR;MAAA;MAAA,WAAAG,SAAA;QAGC,OR7ByB;UAC7B1E,IAAA,EAAM;QAAA,CQ6BH;MAAA;MAUY,OAAAkG,OACXrG,CAAA;QAEA,IAAIqB,CAAA,CAAQrB,CAAA,GAEV,OADAA,CAAA,CAAMsD,OAAA,CAAStD,CAAA,IAAM,KAAKqG,MAAA,CAAOrG,CAAA,IAElC;QAED;YAAMgF,IAAA,EAAE/E,CAAA;YAAFqG,QAAA,EAAQnH,CAAA,IAAW;YAAnBoH,MAAA,EAA0BjH,CAAA,IAAS;UAAA,IAAmBU,CAAA;UAATT,CAAA,GAAAW,CAAA,CAASF,CAAA,EAA5D8F,CAAA;QAEA,IAAIlF,CAAA,CAAI,MAAMX,CAAA,GACZ,MAAU,IAAA8E,SAAA,4BAAqC9E,CAAA;QAGjD;UAAME,IAAA,EAAET;QAAA,IAASH,CAAA;QACjB,IAAIkC,CAAA,CAAa/B,CAAA,GAOf,cAAAH,CAAA,CAFYY,IAAA,EAAAX,MAAA,CAGIqC,cAAA,CAAe,MAAW5B,CAAA,EADtCX,CAAA,GAC4C;UAC5CuD,GAAA,EAAKA,CAAA,KAAMO,CAAA,CAASnD,CAAA,EAAMP,CAAA,EAAMH,CAAA;QAAA,IAGU;UAC5CwC,MAAA,GAAS/B,CAAA;YACP,MAAME,CAAA,GAAIkD,CAAA,CAASnD,CAAA,EAAMP,CAAA,EAAMH,CAAA;YAI/B,OAHIW,CAAA,CAAEoC,SAAA,KACJpC,CAAA,CAAEoC,SAAA,GAAYpC,CAAA,CAAEoC,SAAA,CAAUR,IAAA,CAAK5B,CAAA,KAAMF,CAAA,IAGxCE,CAAA;UAAA;QAAA;QAIL,IAAAN,CAAA;QAgCA,OA9BEA,CAAA,GADEN,CAAA,GACW;UACXuD,IAAA;YACE,MAAM7C,CAAA,GAAcR,MAAA,CAAOwD,MAAA,CAAO,IAAIzD,CAAA;YACtC,OAAIJ,CAAA,GAAA8D,CAAA,CACwBhD,CAAA,EAAMD,CAAA,IAAAyC,CAAA,CAEjBxC,CAAA,EAAMD,CAAA,CACxB;UAAA;UACDwG,UAAA,GAAY;QAAA,IAGD;UACXzE,MAAA,GAAS/B,CAAA;YACP,MAAiBE,CAAA,GAAGV,MAAA,CAAOwD,MAAA,CAAO,CAAd,GAAkBzD,CAAA;YACtC,IAAAD,CAAA;YAUA,OAREA,CAAA,GADEH,CAAA,GACI8D,CAAA,CAAmBhD,CAAA,EAAMC,CAAA,IAEzBuC,CAAA,CAAUxC,CAAA,EAAMC,CAAA,GAGpBA,CAAA,CAAYoC,SAAA,KACdhD,CAAA,CAAIgD,SAAA,GAAYpC,CAAA,CAAYoC,SAAA,CAAUR,IAAA,CAAKxC,CAAA,KAAQU,CAAA,IAAAV,CAGtD;UAAA;UACDkH,UAAA,GAAY;QAAA,GAIHhH,MAAA,CAACqC,cAAA,CAAe,MAAW5B,CAAA,EAAML,CAAA,CAC/C;MAAA;IAAA,GArHMqG,QAAA,GAAsC,IAFbjG,CAAA,CAIzByG,gBAAA,QAEA,GAAAzG,CAAA,CAAA0G,MAAA,GAASvH,CAAA,EANgBa,CAAA,CAwChB2G,MAAA,GAAS7B,CAAA,EAAA9E,CAAA,CACT4G,KAAA,GAAQ3B,CAAA,EACRjF,CAAA,CAAA6G,UAAA,GAAapB,CAAA,EA1CGzF,CAAA,CA2ChB8G,SAAA,GAAY1B,CAAA,EAAApF,CAAA,CACZ+G,OAAA,GAAUxB,CAAA,EA5CMvF,CAAA,CA6ChBgH,QAAA,GAAWtB,CAAA,EAAA1F,CAAA,CACXiH,KAAA,GAAQrB,CAAA,EA2EjB5F,CAAA,CAAAkH,KAAA,GAAQ;MACbZ,QAAA,EAAQA,CAAOtG,CAAA,EAAUC,CAAA,MAC0B,MAA9B+B,CAAA,CAAO/B,CAAA,EAAMD,CAAA,GAAO;MAEzCmH,MAAA,EAAMA,CACJnH,CAAA,EACAC,CAAA,EACAC,CAAA,IAAY,MAEIA,CAAA,GAAG+C,CAAA,CAAmBjD,CAAA,EAAMC,CAAA,IAAOwC,CAAA,CAAUzC,CAAA,EAAMC,CAAA;IAAA,GAlIxCD,CAAA;EAAA;AAuInC,SAASoH,EAAYpH,CAAA,GC/KO;EAC1BgG,IAAA,EAAMA,CAAA,MAD6C;EAEnDhC,IAAA,GAAM;EACNkC,MAAA,EAAQ;EACR7B,MAAA,EAAQ;EACR8B,KAAA,EAAOA,CAAA,KAAM;EACbC,MAAA,EAAQA,CAAA,MAAO,CAAP;EACR3B,OAAA,EAAS;AAAA;EAAA,IAAAvE,CAAA;EDyKT,QAAOA,CAAA,iBAAA6F,CAAA;IAAA,WAAAU,iBAAA;MAIH,OAAAxG,CAAA,KAAY,KAAKgG,QAAA,CAClB;IAAA;IAAA,WAAAQ,iBAE2BvG,CAAA;MAS1B,KAAK+F,QAAA,IARK,MAAN/F,CAAA,GAQiBD,CAAA,MAJX,MAANC,CAAA,GAIiBA,CAAA,GAHEF,CAAA,IAJL,CAAhB,CAQH;IAAA;EAAA,GAhBMiG,QAAA,GADThG,CAAA,KACoDD,CAAA,GAkBrDE,CAAA;AAAA;AAEoB,MAAAmH,CAAA,SAA0CD,CAAA;AAAA,SAAAzD,CAAA,IAAAC,GAAA,EAAAU,CAAA,IAAA6B,KAAA,EAAAZ,CAAA,IAAAwB,OAAA,EAAAhD,CAAA,IAAAC,IAAA,EAAA7E,CAAA,IAAAuH,MAAA,EAAAU,CAAA,IAAAE,WAAA,EAAAxC,CAAA,IAAA6B,MAAA,EAAAU,CAAA,IAAAtE,OAAA,EAAAK,CAAA,IAAAmE,QAAA,EAAA1D,CAAA,IAAAmC,IAAA,EAAAP,CAAA,IAAAoB,UAAA,EAAArC,CAAA,IAAAC,OAAA,EAAAG,CAAA,IAAAC,QAAA,EAAAT,CAAA,IAAAC,MAAA,EAAAE,CAAA,IAAA6B,MAAA,EAAAV,CAAA,IAAAsB,QAAA,EAAA/B,CAAA,IAAA2B,KAAA,EAAAxB,CAAA,IAAA0B,SAAA,EAAAlB,CAAA,IAAAqB,KAAA,EAAA/C,CAAA,IAAAgC,MAAA,EAAAxB,CAAA,IAAAC,MAAA,EAAAlC,CAAA,IAAA0E,MAAA,EAAAlE,CAAA,IAAAuE,eAAA,EAAAxF,CAAA,IAAAyF,YAAA"},"metadata":{},"sourceType":"module","externalDependencies":[]}